DB는 동시에 여러 클라이언트가 쿼리를 실행하게 되는데 이럴 때 같은 데이터를 동시에 접근하게 되는 상황이 많음.

# 1. 트랜잭션 격리수준
`트랜잭션 격리`란 트랜잭션을 서로 격리해서 다른 트랜잭션이 영향을 주지 못하게 하는 것

`트랜잭션 격리수준`이란 동시에 여러 트랜잭션이 처리될 때, **트랜잭션끼리 얼마나 고립되어있는지를 나타낸 것**

- 커밋되지 않은 데이터 읽기 (dirty read)
- 커밋되지 않은 데이터 덮어쓰기 (dirty write)
- 읽는 동안 데이터 변경 (read skew / non-repeatable-read)
- 변경이 유실



# 2. 다양한 격리 수준

## 2-1) Read Uncommitted (사실상 사용x)
- 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용함
- 데이터베이스의 일관성을 유지하는 것이 불가능함
- **Dirty Read** 발생
	1. T1에서 A데이터를 10에서 20으로 변경 (커밋X)
 	2. T2에서 B데이터를 조회 (20)
	3. T1에서 A데이터를 롤백 (20 -> 10)
	4. T2에서 조회한 데이터를 바탕으로 로직 수행(20)

## 2-2) Read Committed
- SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸림
- 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기
- **커밋이 이루어진 트랜잭션만 조회 가능**
- **Non-Repeatable-Read** 발생
      1. T1에서 A데이터를 10으로 변경(20->10)
      2. 2번을 진행하는 중 T2에서 A데이터를 조회 (20 , UNDO 테이블)
      3. 2번이 완료된 후 T2에서 A데이터를 조회 (10)
    


## 2-3) Repeatable Read
- 트랜잭션마다 ID를 부여하여 트랜잭션 ID보다 작은 트랜잭션 번호에서 변경한 것만 읽음
- UNDO 테이블에 백업해두고 실제 레코드 값을 변경함
- **Phantom Read** 발생
	1. T2(Tid = 10) 에서 A데이터를 조회 (20)
	2. T1(Tid = 12) 에서 A데이터를 변경후 커밋(20 -> 10)
	3. T2에서 A데이터를 조회(20 , UNDO 테이블)



## 2-4) Serializable
- 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸림
