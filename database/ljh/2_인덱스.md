# 21.01.12



## 주요 질문



#### 💡 [인덱스란?](#인덱스index)

	* 책의 목차처럼 지정한 칼럼을 정렬하여 데이터를 쉽게 찾을 수 있도록 만든 테이블이다.



#### 💡 [인덱스 구조는?](#인덱스-구조)

* 해쉬테이블과 B+Tree 구조가 있습니다.
* 해쉬테이블은 키 값에 해쉬함수를 적용하여 나온 주소값과 매칭하는 기법이다.
* 하지만 부등호 연산이 많은 db에는 효과적이지 않은 방법이다.
* B+Tree는 LinkedList로 연결된 구조이다.
* 연결된 노드를 따라가면서 일치하는 값으로 가서 읽고, 일치하지 않는 값이 나오면 즉시 중지한다.
* B+Tree는 부등호 연산에 효율적이다.

#### 💡 [인덱스는 어디에 사용하는게 좋나요?](#인덱스를-사용하면-좋은-테이블)

* 연산이 거의 없고 검색을 많이 하는 테이블에 사용하면 좋고, 칼럼의 중복도가 낮은 곳에 사용하면 좋다.

#### 💡 [중복도가 높은 칼럼 예시 하나만 들어주세요.]()

* 성별입니다. 사람은 여자, 남자밖에 없어서 최악의 경우 Full Table Scan을 해야합니다. 이 경우 인덱스를 설정하지 않는 것이 좋습니다.

#### 💡 [인덱스를 따로 설정하지 않으면 어떻게 되는가?](#인덱스index)

* 인덱스를 설정하지 않아도 기본적으로 PK값이 인덱스로 설정되어 있습니다.

#### 💡 [속도를 위해 모든 칼럼에 인덱스를 넣으면 되지 않는가?](#인덱스index)

* 인덱스는 인덱스 설정된 컬럼을 추가 저장공간에 저장하고 재정렬해서 사용합니다. 그렇기 때문에 모든 컬럼에 인덱스를 넣게 되면 저장공간을 많이 차지하게 됩니다. 또한, 데이터를 재정렬하기 때문에 삽입, 삭제, 갱신이 발생하게 되면 인덱스 테이블은 이 데이터들에 대해 재정렬을 다시 수행해야 하므로 오히려 성능 저하로 이어지게 됩니다.

<br />

## ⭐ 개념 정리

### 인덱스

``` sql
CREATE INDEX 인덱스명 ON 테이블명(컬럼명)
```



* 인덱스는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료구조입니다.
* 특정 칼럼에 인덱스를 생성하면, ,해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장됩니다.
* 이렇게 인덱스를 생성하였다면 앞으로 쿼리문에 "인덱스 생성 컬럼을 Where 조건으로  거는 등"의 작업을 하면 옵티마이저에서 판단하여 생성된 인덱스르 탈 수 있습니다. 
* 만약 인덱스를 타게 된다면 아래의 그림과 같이 인덱스를 타게 되고 먼저 인덱스에 저장되어 있는 데이터의 물리적 주소로 가서 데이터를 가져오는 식으로 동작을 하여 검색 속도의 향상을 가져올 수 있습니다.

<img width="483" alt="스크린샷 2022-01-12 오후 7 22 09" src="https://user-images.githubusercontent.com/60912550/149243837-83fa2fc7-202e-4016-b4a4-8dd56aeaed80.png">

* 즉 인덱스는 책에 있는 목차라고 생각하면 편하다.

* 우리가 책에서 정보를 찾을 때도 먼저 원하는 카테고리를 목차에서 찾고 목차에 있는 페이지번호를 보고 찾아가듯 인덱스도 인덱스에서 내가 원하는 데이터를 먼저 찾고 저장되어 있는 물리적 주소로 찾아갑니다.

* 실제 DB 관련 작업을 할 때 대부분의 속도저하는 바로 select문 특히 조건 검색 where절에서 발생하는데 가장 먼저 생각해 볼 수 있는 대안으로 인덱스를 생각할 수 있고 SQL튜닝에서도 인덱스와 관련된 문제사항과 해결책이 많기 때문이다.

* 인덱스를 설정하지 않은 경우, 기본적으로 PK값이 인덱스로 사용된다.

  <br />

### 인덱스를 사용하면 좋은 테이블

* 규모가 작지 않은 테이블
* 삽입, 삭제, 갱신이 자주 발생하지 않는 테이블
* 데이터 중복도가 낮은 컬럼

<br />

### 인덱스(Index)의 장점

  * 인덱스를 사용하는 이유
    * 인덱스의 가장 큰 특징은 데이터들이 정렬이 되어있다는 점이다. 이 특징으로 인해 조건검색이라는 영역에서 굉장한 장점이 된다.

  * 조건 검색 Where 절의 효율성
    * 테이블을 만들고 안에 데이터가 쌓이게 되면 테이블의 레코드는 내부적으로 순서가 없이 뒤죽박죽으로 저장된다.
    * 이렇게 되면 where절의 특정 조건에 맞는 데이터들을 찾아낼 때 레코드의 처음부터 끝까지 다 읽어서 검색조건에 부합하는지 비교해야 한다.
    * 이것을 풀 테이블 스캔(Full Table Scan)이라고 한다.
    * 하지만 인덱스 테이블은 데이터들이 정렬되어 저장되어 있기 때문에 해당 조건(where)에 맞는 데이터들을 빠르게 찾아낼 수 있다.
    * 이것이 인덱스를 사용하는 가장 큰 이유이다.

  * 정렬 Order by 절의 효율성
    * 인덱스를 사용하면 order by에 의한 sort과정을 피할 수 있습니다. order by는 굉장히 부하가 많이 걸리는 작업이다.
    * 정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지고 메모리보다 큰 작업이 필요하다면 디스크 I/O도 추가적으로 발생된다.
    * 하지만 인덱스를 사용하면 이러한 전반적인 자원의 소모를 하지 않아도 된다.
    * 이미 정렬이 되어 있기 때문에 가져오기만 하면 되기 때문이다.

  * MIN, MAX의 효율적인 처리가 가능하다.
    * 이것 또한 데이터가 정렬되어 있기에 얻을 수 있는 장점이다.
    * MIN값과 MAX값을 레코드의 시작값과 끝 값 한 건씩만 가져오면 되기 때문에 Full Table Scan으로 테이블을 다 뒤져서 작업하는 것보다 훨씬 효율적으로 찾을 수 있다.

  <br />

### 인덱스(Index)의 단점

  * 인덱스가 주는 혜택이 있으면 그에 따른 부작용도 있다. 인덱스의 가장 큰 문제점은 정렬된 상태를 계속 유지 시켜줘야 한다는 점이다.
  * 그렇기에 레코드 내 데이터값이 바뀌는 부분이라면 악영향을 미친다. insert, update, delete를 통해 데이터가 추가되거나 값이 바뀐다면 index테이블 내에 있는 값들을 다시 정렬 해야한다. 그리고 index테이블, 원본 테이블 이렇게 두 곳에서 데이터 수정 작업을 해줘야 한다는 담점이 있다.
  * 또한 검색 시에도 인덱스가 무조건 좋은 것이 아니다. 인덱스는 테이블의 전체 데이터 중에서 10~15%이하의 데이터를 처리하는 경우에만 효율적이고 그 이상의 데이터를 처리할 땐 인덱스를 사용하지 않는 것이 더 낫다.
  * 그리고 인덱스를 관리하기 위해서는 데이터베이스의 약 10%에 해당하는 저장공간이 추가로 필요하다. 무턱대로 index를 만들어서는 안된다.
  * 인덱스(Index)의 관리
    * 인덱스는 항상 최신의 데이터를 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다. 그렇기 때문에 인덱스가 적용된 칼럼에 insert, update, delete가 수행된다면 계속 정렬을 해주어야 하고, 그에 따른 부하가 발생한다. 이런 부하를 최소화하기 위해 인덱스는 데이터 삭제라는 개념에서 인덱스를 사용하지 않는다는 작업으로 이를 대신한다.
    * INSERT : 새로운 데이터에 대한 인덱스를 추가한다.
    * DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행한다.
    * UPDATE : 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가합니다.

    <br />

### 인덱스 생성 전략

  * 생성된 인덱스를 가장 효율적으로 사용하려면 데이터의 분포도는 최대한으로, 그리고 조건절에 호출 빈도는 자주 사용되는 컬럼을 인덱스로 생성하는 것이 좋다.
  * 인덱스는 특정 컬럼을 기준으로 생성하고 기준이 된 컬럼으로 정렬된 Index 테이블이 생성된다. 이 기준 칼럼은 최대한 중복이 되지 않는 값이 좋다.
  * 가장 최선은 PK로 인덱스를 거는 것이다. 중복된 값이 없는 인덱스 테이블이 최적의 효율을 발생시키겠고 반대로 모든 값이 같은 컬럼이 인덱스 컬럼이 된다면 인덱스로써의 가치가 없다고 봐야할 것이다.

<br />

### 인덱스 구조
   * 해쉬테이블  
      ![image](https://user-images.githubusercontent.com/36289638/104845473-081b6680-5919-11eb-9f7c-8d9acc1d90e7.png)


        * 해쉬함수에 의해 값이 주소값에 매핑된다.
        * equal 관계에서는 효율적이지만, 범위 연산이 많은 DB 연산에서는 비효율적

<br/>

   * B+Tree  
      ![image](https://user-images.githubusercontent.com/36289638/104845458-f639c380-5918-11eb-8f54-93059b90bd3f.png)

        * LinkedList로 연결
        * 일치하지 않는 값이 나오면 탐색을 중지
        * 만약 위의 그림에서 52번이 9번 블록 끝까지 있다면 10번 노드도 탐색

<br/>

### B-Tree Index

* 인덱스에는 여러가지 유형이 있지만 그 중에서도 가장 많이 사용하는 인덱스의 구조는 밸런스드 트리 인덱스 구조이다.
* 그리고 B-Tree Index 중에서도 가장 많이 사용하는 것은 B*Tree 와 B+Tree구조를 가장 많이 사용한다.

<img width="723" alt="스크린샷 2022-01-13 오전 9 48 43" src="https://user-images.githubusercontent.com/60912550/149246277-bb9cfc81-4d77-4c5f-81e9-0fb94f7c721c.png">

* B*Tree 인덱스는 대부분의 DBMS 그리고 오라클에서 특히 중점적으로 사용하고 있는 가장 보편적인 인덱스이다.
* 구조는 위와같이 Root(기준) / Branch(중간) / Leaf(말단) Node로 구성된다.
* 특정 컬럼에 인덱스를 생성하는 순간 컬럼의 값들이 정렬하는데, 정렬한 순서가 중간 쯤 되는 데이터를 뿌리에 해당하는 ROOT 블록으로 지정하고 ROOT블록을 기준으로 가지가 되는 BRANCH블록을 정의하며 마지막으로 잎에 해당하는 LEAF블록에 인덱스의 키가 되는 데이터와 데이터의 물리적 주소정보인 ROWID를 저장한다. 

<br />