# 21.01.17



## 주요 질문



#### 💡 [교착상태(DeadLock)란 무엇인가?](#교착상태)

	* 데이터베이스에서 교착상태(DeadLock)란 여러 개의 트랜잭션들이 실행을 하지 못하고 서로 무한정 기다리는 상태를 의미합니다.



#### 💡 [교착상태(DeadLock)를 해결하는 방법은 무엇이 있나요?](#교착상태(DeadLock)를-해결하는-방법)

* 예방기법과 회피기법이 있습니다.

<br />

## ⭐ 개념 정리

### 교착상태(DeadLock)

```markdown
데이터베이스에서 교착상태(DeadLock)란 여러 개의 트랜잭션들이 실행을 하지 못하고 서로 무한정 기다리는 상태를 의미합니다.
기본적으로 데이터베이스에서는 트랜잭션들의 '동시성'을 제어하기 위한 기법으로 '로킹(Locking)'을 사용합니다. 이러한 로킹이 데이터가 엉망진창이 되는 것을 막아주겠지만 반면에 그 부작용으로 교착상태를 일으킬 수 있다는 것이 핵심 키워드입니다.
```

<br />

### 교착상태(DeadLock)를 해결하는 방법

1. 예방 기법

* 예방기법은 각 트랜잭션이 실행되기 전에 필요한 데이터를 모두 로킹(Locking) 해주는 것입니다.
* 다만 예방 기법은 데이터가 많이 필요하면 사실상 모든 데이터를 전부 로킹 해주어야 하므로 트랜잭션의 병행성을 보장하지 못합니다.
* 뿐만 아니라 몇몇 트랜잭션은 계속해서 처리를 못하게 되는 기아상태가 발생할 수 있습니다.

2. 회피 기법

   * 예방 기법의 단점 때문에 실제로 교착상태를 해결하기 위한 방법으로 회피 기법이 많이 사용됩니다.
   * 회피 기법은 자원을 할당할 때 시간 프탬프(Time Stamp)를 사용하여 교착상태가 일어나지 않도록 회피하는 방법입니다.
   * 이러한 회피 기법으로는 Wait-Die 방식과 Wound-Wait 방식이 있습니다.

   > * Wait-Die 방식 : 트랜잭션 Ti가 Tj에 의해 로킹된 데이터를 요청할 때 Ti가 먼저 들어온 트랜잭션이라면 기다립니다.
   >   반면에 Ti가 나중에 들어온 트랜잭션이라면 포기(Die)하고, 나중에 다시 요청합니다. 즉, 다른 트랜잭션이
   >   데이터를 점유하고 있을 때 기다리거나(Wait) 포기(Die)하는 방식입니다.

   > * Wound-Wait 방식 : 트랜잭션 Ti가 Tj에 의해 로킹된 데이터를 요청할 때 Ti가 먼저 들어온 트랜잭션이라면 데이터를 선점(Wound)합니다.
   >   반면에 Ti가 나중에 들어온 트랜잭션이라면 기다립니다.(Wait)
   >   즉, 다른 트랜잭션이 데이터를 점유하고 있을 때 빼앗거나(Wound) 기다리는(Wait) 방식입니다.

<br />

### 교착상태(DeadLock) 탐지하는 방법

> 교착상태가 발생했는 지 알아내기 위해 사용하는 알고리즘은 Union-Find 알고리즘입니다.
> 그래프 형태로 표현이 가능하며, 사이클(Cycle)이 존재하는지의 여부로 교착 상태가 발생했는지 확인할 수 있습니다.

<img width="679" alt="스크린샷 2022-01-17 오전 9 37 10" src="https://user-images.githubusercontent.com/60912550/149684653-7e683cc3-dce3-4fab-949c-b0519e79d8c4.png">

* 예를 들어 위와 같이 트랜잭션이 처리된다고 할 때 수행순서 (8) 때의 대기 그래프는 다음과 같다.

<img width="555" alt="스크린샷 2022-01-17 오전 9 38 58" src="https://user-images.githubusercontent.com/60912550/149684696-797d2aa2-58fc-4fed-88db-ec8cb2a411fd.png">

* 이 경우 위와 같이 T1, T3, T4가 사이클을 이루고 있다는 점에서 교착 상태임을 확인할 수 있습니다.

> 시간 스탬프(Time Stamp) 기법은 트랜잭션을 기준으로 하는 것이 아니라 각 데이터를 기준으로 하여 시간 순서대로 제어하는 기법입니다.
> 쉽게 말해 트랜잭션에서 데이터를 처리하는 부분을 읽기(Read)와 쓰기(Write)로 나누어 계산하는 방법입니다.
> 처음부터 시간 순서대로 제어를 한다는 점에서 시간 측면의 문제는 발생하지 않습니다.
> 즉, 먼저 처리되고 이쓴ㄴ 것에게 자신이 양보를 하게 됩니다.

<img width="698" alt="스크린샷 2022-01-17 오전 9 43 06" src="https://user-images.githubusercontent.com/60912550/149684849-9b244f33-9d8b-47e4-a151-19b9b3ff91de.png">

* 중요한 점은 '포기'하는 경우 가장 마지막 순서로 다시 해당 데이터를 처리할 수 있도록 들어갑니다.
* 시간 순서를 가장 뒤로 이동할 뿐 결과적으로 언젠가는 수행을 할 수 있도록 처리하는 것입니다.
* 또한 앞선 트랜잭션이 데이터를 '읽기만'하는 경우 자신도 '읽기만'하는 것은 문제가 되지 않는 점을 기억하면 된다.

> 낙관적 병행 제어 기법은 트랜잭션이 실행되는 동안에는 아무런 검사를 하지 않고, 트랜잭션이 다 실행된 이후에 검사하여 문제가 있다면 되돌리는 방식입니다. 이러한 낙관적 병행 제어 기법은 총 3단계로 수행되는데 차례대로 (1) 판독 단게, (2) 확인 단계, (3) 기록 단계입니다.
> (2) 확인 단계를 성공적으로 거친 트랜잭션에 한해서만 실제로 (3) 단계 기록을 수행할 수 있도록 합니다.
