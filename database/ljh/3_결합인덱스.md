# 21.01.13



## 주요 질문



#### 💡 [결합 인덱스란?](#결합인덱스index)

	두 개 이상의 컬럼을 합쳐서 인덱스를 만드는 것을 말합니다.
	주로 단일 컬럼으로는 나쁜 분포도를 가지지만 여러개의 컬럼을 합친다면 좋은 분포도를 가지고, where절에서 and조건에 많이 사용되는 컬럼들을 결합 인덱스로 구성합니다.



#### 💡 [인덱스 구조는?](#인덱스-구조)

* 해쉬테이블과 B+Tree 구조가 있습니다.
* 해쉬테이블은 키 값에 해쉬함수를 적용하여 나온 주소값과 매칭하는 기법이다.
* 하지만 부등호 연산이 많은 db에는 효과적이지 않은 방법이다.
* B+Tree는 LinkedList로 연결된 구조이다.
* 연결된 노드를 따라가면서 일치하는 값으로 가서 읽고, 일치하지 않는 값이 나오면 즉시 중지한다.
* B+Tree는 부등호 연산에 효율적이다.

#### 💡 [인덱스는 어디에 사용하는게 좋나요?](#인덱스를-사용하면-좋은-테이블)

* 연산이 거의 없고 검색을 많이 하는 테이블에 사용하면 좋고, 칼럼의 중복도가 낮은 곳에 사용하면 좋다.

#### 💡 [중복도가 높은 칼럼 예시 하나만 들어주세요.]()

* 성별입니다. 사람은 여자, 남자밖에 없어서 최악의 경우 Full Table Scan을 해야합니다. 이 경우 인덱스를 설정하지 않는 것이 좋습니다.

#### 💡 [인덱스를 따로 설정하지 않으면 어떻게 되는가?](#인덱스index)

* 인덱스를 설정하지 않아도 기본적으로 PK값이 인덱스로 설정되어 있습니다.

#### 💡 [속도를 위해 모든 칼럼에 인덱스를 넣으면 되지 않는가?](#인덱스index)

* 인덱스는 인덱스 설정된 컬럼을 추가 저장공간에 저장하고 재정렬해서 사용합니다. 그렇기 때문에 모든 컬럼에 인덱스를 넣게 되면 저장공간을 많이 차지하게 됩니다. 또한, 데이터를 재정렬하기 때문에 삽입, 삭제, 갱신이 발생하게 되면 인덱스 테이블은 이 데이터들에 대해 재정렬을 다시 수행해야 하므로 오히려 성능 저하로 이어지게 됩니다.

<br />

## ⭐ 개념 정리

### 결합 인덱스

``` sql
create index emp_pay_idx on emp_pay(급여년월, 급여코드, 사원번호);
```



* 두 개 이상의 컬럼을 합쳐서 인덱스를 만드는 것
* 주로 단일 컬럼으로는 나쁜 분포도를 가지지만 여러개의 컬럼을 합친다면 좋은 분포도를 가지고, where절에서 and조건에 많이 사용되는 컬럼들을 결합 인덱스로 구성한다.

<br />

### 결합 인덱스 컬럼 선택

* where절에서 and조건으로 자주 결합되어 사용되면서 각각의 분포도 보다 두 개 이상의 컬럼이 결합될 때 분포도가 좋아지는 컬럼들
* 다른 테이블과 조인의 연결고리로 자주 사용되는 컬럼들
* order by에서 자주 사용되는 컬럼들
* 하나 이상의 키 컬럼 조건으로 같은 테이블의 컬럼들이 자주 조회될 때

<br />

### 결합 인덱스의 컬럼 순서 결정

* 결합 인덱스를 만들 때 결합 인덱스를 구성하는 컬럼들의 배열 순서는 아주 중요하기에 신중하게 결정하여야 한다.
* 컬럼의 순서를 잘못 배열하면 결합 인덱스의 발동 확률이 매우 낮아질 수 있기 때문이다.
* 만약 select문의 where절에 결합 인덱스의 첫 번째 컬럼을 조건에 사용하였다면 그 질의문은 결합 인덱스를 사용할 수 있다.
* 하지만 결합 인덱스의 두번째 컬럼만을 where절에 조건으로 사용하고 결합 인덱스를 사용하려 했다면 실행계획은 인덱스를 사용하지 못한다. 
* 따라서 쿼리문 작성 시 결합 인덱스를 사용하고자 한다면 반드시 결합 인덱스의 컬럼 중 선행하는 컬럼부터 조건에 지정하여 사용하여야 한다.
* 조건은 컬럼 전체를 순서대로 사용할 수도 있고, 선행하는 일부 컬럼을 순서대로 사용할 수 있다.

<br />

### 결합 인덱스 컬럼의 설정 시 고려해야 할 우선순위

1. where절 조건에 많이 사용되는 컬럼이 우선
2. Equal('=')로 사용되는 컬럼 우선
3. 분포도가 좋은 컬럼을 우선
4. 자주 이용되는 순서대로 결합 인덱스 컬럼의 순서 결정

<br />

### 결합 인덱스 사용 예시

* 결합 인덱스 생성

  ``` sql
  create index emp_pay_idx on emp_pay(급여년월, 급여코드, 사원번호);
  ```

​	emp_pay 테이블에서 급여년월, 급여코드, 사원번호 컬럼으로 emp_pay_idx라는 결합 인덱스를 생성했습니다.

* 결합 인덱스 사용

  ``` sql
  select * from emp_pay where 급여년월 = '202107';
  select * from emp_pay where 급여년월 = '202107' and 급여코드 ='정기급여';
  select * from emp_pay where 급여년월 = '202107' and 급여코드 = '정기급여' and 사원번호 = '20210401';
  ```

  select 문장의 where절에서는 다음과 같은 조건 조합에서 인덱스가 사용되게 된다.

* 결합 인덱스가 사용되지 않는 경우

``` sql
select * from emp_pay where 급여코드 = '정기급여';
select * from emp_pay where 사원번호 = '20210401';
select * from emp_pay where 사원번호 = '20210401' and 급여코드 = '정기급여';
```

위와 같이 where 조건문을 나열할 때 결합 인덱스의 첫 번째 컬럼인 급여년월의 조건식이 없으면 B*Tree구조인 결합 인덱스를 검색할 수 없기 때문에 결합 인덱스가 무용지물이 되니 주의해야 한다.

* 결합 인덱스의 효율성이 떨어지는 경우

  결합 인덱스도 일반적인 인덱스와 마찬가지로 데이터들이 정렬되어 보관되기 때문에 소수의 데이터를 빠르게 찾는 것에는 유리하지만 아래와 같이 스캔이 ㅁ낳이 생기게 된다면 효율성이 떨어지게 된다.

  아래의 예시들은 emp_pay_idx 인덱스를 사용하기는 하지만 스캔이 많이 생기는 경우로 인덱스의 효율성이 떨어지는 경우들의 예시이다.

```sql
select * from emp_pay where 급여년월 LIKE '2021%' and 급여코드 = '정기급여';
```

위 조건절의 경우 결합 인덱스의 첫 번째 컬럼인 급여년월의 조건이 있더라도 Equal('=')이 아닌 범위 연산자인 LIKE '2021%' 조건을 사용했으므로, 세개의 컬럼이 모두 필요한 emp_pay_idx인덱스를 찾을 때 두번째 컬럼인 급여코드에 대한 조건을 B*Tree에서 쉽게 찾을 수가 없게 된다. 이는 결합 인덱스가 각 컬럼별로 정렬이 되어 있는 것이 아니라 첫번째, 두번째, 세번째 컬럼이 결합이 되어 정렬이 되어있기 때문이다. 이때 급여코드에 대한 조건은 인덱스를 찾아가는 검색조건이 아니라 인덱스 값이 조건에 맞는지 여부를 검증하는 체크 조건이 된다.

```sql
select * from emp_pay where 급여년월 = '202107' and 사원번호 = '20210401';

```

위 조건절의 경우는 결합 인덱스의 첫번째 컬럼인 급여년월의 조건이 Equal('=')이더라도 두번째 컬럼인 급여코드에 대한 조건이 없으므로 세번째 컬럼인 사원번호 조건을 검색 조건이 아닌 체크 조건으로 밖에 사용할 수 없게 된다. 즉 결합 인덱스에서 급여년원인 모든 데이터를 찾아서 사원번호 조건에 맞는지 일일이 확인하는 Full Table Scan이 일어나고 있는 셈이다.